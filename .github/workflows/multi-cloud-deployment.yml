name: Multi-Cloud Deployment (Cloudflare R2 + Azure Container Apps + Cloudflare Pages + Cloudflare DNS)

on:
  workflow_dispatch:
    inputs:
      environment:
        description: 'Environment to deploy'
        required: true
        type: choice
        options:
          - dev
          - staging
          - production
      release_tag:
        description: 'Git tag/version to deploy (e.g., v1.2.3)'
        required: true
        type: string
      deploy_cloudflare:
        description: 'Deploy Cloudflare R2 infrastructure'
        required: false
        type: boolean
        default: true
      deploy_azure:
        description: 'Deploy Azure Container Apps backend'
        required: false
        type: boolean
        default: true
      deploy_postgres:
        description: 'Deploy Azure PostgreSQL infrastructure'
        required: false
        type: boolean
        default: true
  pull_request:
    branches:
      - main
    paths:
      - 'infrastructure/multi-cloud/terraform/**'
      - '.github/workflows/multi-cloud-deployment.yml'
  workflow_run:
    workflows: ["Build Pipeline"]
    types:
      - completed
    branches:
      - main

permissions:
  id-token: write      # Required for OIDC authentication with Azure
  contents: read       # Required for checking out code
  pull-requests: write # Required for commenting on PRs

env:
  TERRAFORM_VERSION: '1.6.0'
  CLOUDFLARE_TERRAFORM_DIR: 'dculus-forms/infrastructure/multi-cloud/terraform/cloudflare'
  CLOUDFLARE_SERVICE_TERRAFORM_DIR: 'dculus-forms/infrastructure/multi-cloud/terraform/cloudflare-service-domain'
  CLOUDFLARE_PAGES_TERRAFORM_DIR: 'dculus-forms/infrastructure/multi-cloud/terraform/cloudflare-pages'
  CLOUDFLARE_PAGES_ADMIN_TERRAFORM_DIR: 'dculus-forms/infrastructure/multi-cloud/terraform/cloudflare-pages-admin'
  CLOUDFLARE_PAGES_VIEWER_TERRAFORM_DIR: 'dculus-forms/infrastructure/multi-cloud/terraform/cloudflare-pages-viewer'
  AZURE_TERRAFORM_DIR: 'dculus-forms/infrastructure/multi-cloud/terraform/azure'
  POSTGRES_TERRAFORM_DIR: 'dculus-forms/infrastructure/multi-cloud/terraform/azure-postgres'

jobs:
  # ============================================================
  # PHASE 1: ENVIRONMENT SETUP & VALIDATION
  # ============================================================

  determine-environment:
    name: 1.1. Determine Deployment Environment
    runs-on: ubuntu-latest
    outputs:
      environment: ${{ steps.set-env.outputs.environment }}
      should_deploy: ${{ steps.set-env.outputs.should_deploy }}
      deploy_cloudflare: ${{ steps.set-env.outputs.deploy_cloudflare }}
      deploy_azure: ${{ steps.set-env.outputs.deploy_azure }}
      deploy_postgres: ${{ steps.set-env.outputs.deploy_postgres }}
      release_tag: ${{ steps.set-env.outputs.release_tag }}
      release_commit: ${{ steps.resolve-release.outputs.release_commit || steps.set-env.outputs.release_commit }}
    steps:
      - name: Determine environment
        id: set-env
        run: |
          # For manual workflow dispatch
          if [ "${{ github.event_name }}" = "workflow_dispatch" ]; then
            echo "environment=${{ github.event.inputs.environment }}" >> $GITHUB_OUTPUT
            echo "should_deploy=true" >> $GITHUB_OUTPUT
            echo "deploy_cloudflare=${{ github.event.inputs.deploy_cloudflare }}" >> $GITHUB_OUTPUT
            echo "deploy_azure=${{ github.event.inputs.deploy_azure }}" >> $GITHUB_OUTPUT
            echo "deploy_postgres=${{ github.event.inputs.deploy_postgres }}" >> $GITHUB_OUTPUT
            echo "release_tag=${{ github.event.inputs.release_tag }}" >> $GITHUB_OUTPUT
            exit 0
          fi

          # For workflow_run (triggered by Build Pipeline)
          if [ "${{ github.event_name }}" = "workflow_run" ]; then
            echo "‚ÑπÔ∏è Triggered by Build Pipeline completion"
            
            # Check if build was successful
            if [ "${{ github.event.workflow_run.conclusion }}" != "success" ]; then
              echo "‚ùå Build Pipeline failed. Skipping deployment."
              exit 1
            fi
            
            # Determine tag/commit
            HEAD_BRANCH="${{ github.event.workflow_run.head_branch }}"
            HEAD_SHA="${{ github.event.workflow_run.head_sha }}"
            
            echo "Branch: $HEAD_BRANCH"
            echo "SHA: $HEAD_SHA"
            
            if [ "$HEAD_BRANCH" = "main" ]; then
              # For main branch, deploy to dev with SHA tag
              echo "environment=dev" >> $GITHUB_OUTPUT
              echo "should_deploy=true" >> $GITHUB_OUTPUT
              echo "deploy_cloudflare=true" >> $GITHUB_OUTPUT
              echo "deploy_azure=true" >> $GITHUB_OUTPUT
              echo "deploy_postgres=true" >> $GITHUB_OUTPUT
              echo "release_tag=sha-${HEAD_SHA}" >> $GITHUB_OUTPUT
              echo "release_commit=${HEAD_SHA}" >> $GITHUB_OUTPUT
            else
               echo "‚ö†Ô∏è Triggered by non-main branch: $HEAD_BRANCH. Skipping auto-deployment."
               echo "should_deploy=false" >> $GITHUB_OUTPUT
            fi
            exit 0
          fi

          # For pull requests, only plan (no deploy)
          if [ "${{ github.event_name }}" = "pull_request" ]; then
            echo "environment=dev" >> $GITHUB_OUTPUT
            echo "should_deploy=false" >> $GITHUB_OUTPUT
            echo "deploy_cloudflare=true" >> $GITHUB_OUTPUT
            echo "deploy_azure=true" >> $GITHUB_OUTPUT
            echo "deploy_postgres=true" >> $GITHUB_OUTPUT
            echo "release_tag=${{ github.sha }}" >> $GITHUB_OUTPUT
            echo "release_commit=${{ github.sha }}" >> $GITHUB_OUTPUT
            exit 0
          fi

      - name: Validate release tag
        id: resolve-release
        if: github.event_name == 'workflow_dispatch'
        env:
          GH_TOKEN: ${{ github.token }}
        run: |
          TAG="${{ steps.set-env.outputs.release_tag }}"

          if [ -z "$TAG" ]; then
            echo "‚ùå Release tag input is required."
            exit 1
          fi

          echo "üîç Validating release tag: $TAG"

          REF_JSON=$(gh api repos/${{ github.repository }}/git/ref/tags/${TAG} 2>/tmp/ref_error || true)

          if [ -z "$REF_JSON" ]; then
            echo "‚ùå Tag '$TAG' was not found in repository ${{ github.repository }}"
            echo "Details:"
            cat /tmp/ref_error || true
            exit 1
          fi

          OBJECT_SHA=$(echo "$REF_JSON" | jq -r '.object.sha')
          OBJECT_TYPE=$(echo "$REF_JSON" | jq -r '.object.type')

          if [ "$OBJECT_TYPE" = "tag" ]; then
            COMMIT_SHA=$(gh api repos/${{ github.repository }}/git/tags/${OBJECT_SHA} --jq '.object.sha')
          else
            COMMIT_SHA="$OBJECT_SHA"
          fi

          echo "‚úÖ Tag resolved to commit: $COMMIT_SHA"
          echo "release_commit=$COMMIT_SHA" >> $GITHUB_OUTPUT

      - name: Display environment info
        run: |
          echo "üåç Deploying to: ${{ steps.set-env.outputs.environment }}"
          echo "üöÄ Should deploy: ${{ steps.set-env.outputs.should_deploy }}"
          echo "‚òÅÔ∏è Deploy Cloudflare: ${{ steps.set-env.outputs.deploy_cloudflare }}"
          echo "üî∑ Deploy Azure: ${{ steps.set-env.outputs.deploy_azure }}"
          echo "üêò Deploy PostgreSQL: ${{ steps.set-env.outputs.deploy_postgres }}"
          echo "üè∑Ô∏è Release tag: ${{ steps.set-env.outputs.release_tag }}"
          echo "üîÅ Release commit: ${{ steps.resolve-release.outputs.release_commit || steps.set-env.outputs.release_commit }}"
          echo "üîÄ Event: ${{ github.event_name }}"
          echo "üìå Ref: ${{ github.ref }}"

  setup-azure-backend:
    name: 1.2. Setup Azure Terraform Backend
    runs-on: ubuntu-latest
    needs: determine-environment
    if: needs.determine-environment.outputs.should_deploy == 'true'
    environment: ${{ needs.determine-environment.outputs.environment }}
    steps:
      - name: Azure Login (OIDC)
        uses: azure/login@v2
        with:
          client-id: ${{ secrets.AZURE_CLIENT_ID }}
          tenant-id: ${{ secrets.AZURE_TENANT_ID }}
          subscription-id: ${{ secrets.AZURE_SUBSCRIPTION_ID }}

      - name: Create Azure Storage containers for Terraform state
        run: |
          ENV="${{ needs.determine-environment.outputs.environment }}"
          RESOURCE_GROUP="dculus-global-terraform-assets-resource-grp"
          STORAGE_ACCOUNT="dculusterraformstates"
          LOCATION="centralindia"

          echo "üì¶ Setting up Terraform backend for environment: $ENV"

          # Create resource group if it doesn't exist
          if ! az group show --name "$RESOURCE_GROUP" &>/dev/null; then
            echo "üì¶ Creating resource group: $RESOURCE_GROUP in $LOCATION"
            az group create \
              --name "$RESOURCE_GROUP" \
              --location "$LOCATION"
            echo "‚úÖ Resource group created: $RESOURCE_GROUP"
          else
            echo "‚úÖ Resource group exists: $RESOURCE_GROUP"
          fi

          # Create storage account if it doesn't exist
          if ! az storage account show \
            --name "$STORAGE_ACCOUNT" \
            --resource-group "$RESOURCE_GROUP" &>/dev/null; then
            echo "üì¶ Creating storage account: $STORAGE_ACCOUNT in $LOCATION"
            az storage account create \
              --name "$STORAGE_ACCOUNT" \
              --resource-group "$RESOURCE_GROUP" \
              --location "$LOCATION" \
              --sku Standard_LRS \
              --kind StorageV2 \
              --allow-blob-public-access false \
              --min-tls-version TLS1_2
            echo "‚úÖ Storage account created: $STORAGE_ACCOUNT"
          else
            echo "‚úÖ Storage account exists: $STORAGE_ACCOUNT"
          fi

          # Create Cloudflare R2 container
          CLOUDFLARE_CONTAINER="dculus-forms-cloudflare-r2-${ENV}-state"
          if ! az storage container show \
            --name "$CLOUDFLARE_CONTAINER" \
            --account-name "$STORAGE_ACCOUNT" &>/dev/null; then
            echo "üì¶ Creating container: $CLOUDFLARE_CONTAINER"
            az storage container create \
              --name "$CLOUDFLARE_CONTAINER" \
              --account-name "$STORAGE_ACCOUNT" \
              --auth-mode login
            echo "‚úÖ Container created: $CLOUDFLARE_CONTAINER"
          else
            echo "‚úÖ Container exists: $CLOUDFLARE_CONTAINER"
          fi

          # Create Cloudflare service-domain container
          CLOUDFLARE_SERVICE_CONTAINER="dculus-forms-cloudflare-services-${ENV}-state"
          if ! az storage container show \
            --name "$CLOUDFLARE_SERVICE_CONTAINER" \
            --account-name "$STORAGE_ACCOUNT" &>/dev/null; then
            echo "üì¶ Creating container: $CLOUDFLARE_SERVICE_CONTAINER"
            az storage container create \
              --name "$CLOUDFLARE_SERVICE_CONTAINER" \
              --account-name "$STORAGE_ACCOUNT" \
              --auth-mode login
            echo "‚úÖ Container created: $CLOUDFLARE_SERVICE_CONTAINER"
          else
            echo "‚úÖ Container exists: $CLOUDFLARE_SERVICE_CONTAINER"
          fi

          # Create Azure Container Apps container
          AZURE_CONTAINER="dculus-forms-azure-backend-${ENV}-state"
          if ! az storage container show \
            --name "$AZURE_CONTAINER" \
            --account-name "$STORAGE_ACCOUNT" &>/dev/null; then
            echo "üì¶ Creating container: $AZURE_CONTAINER"
            az storage container create \
              --name "$AZURE_CONTAINER" \
              --account-name "$STORAGE_ACCOUNT" \
              --auth-mode login
            echo "‚úÖ Container created: $AZURE_CONTAINER"
          else
            echo "‚úÖ Container exists: $AZURE_CONTAINER"
          fi

          # Create Cloudflare Pages container
          CLOUDFLARE_PAGES_CONTAINER="dculus-forms-cloudflare-pages-${ENV}-state"
          if ! az storage container show \
            --name "$CLOUDFLARE_PAGES_CONTAINER" \
            --account-name "$STORAGE_ACCOUNT" &>/dev/null; then
            echo "üì¶ Creating container: $CLOUDFLARE_PAGES_CONTAINER"
            az storage container create \
              --name "$CLOUDFLARE_PAGES_CONTAINER" \
              --account-name "$STORAGE_ACCOUNT" \
              --auth-mode login
            echo "‚úÖ Container created: $CLOUDFLARE_PAGES_CONTAINER"
          else
            echo "‚úÖ Container exists: $CLOUDFLARE_PAGES_CONTAINER"
          fi

          # Create Cloudflare Pages Admin container
          CLOUDFLARE_PAGES_ADMIN_CONTAINER="dculus-forms-cloudflare-pages-admin-${ENV}-state"
          if ! az storage container show \
            --name "$CLOUDFLARE_PAGES_ADMIN_CONTAINER" \
            --account-name "$STORAGE_ACCOUNT" &>/dev/null; then
            echo "üì¶ Creating container: $CLOUDFLARE_PAGES_ADMIN_CONTAINER"
            az storage container create \
              --name "$CLOUDFLARE_PAGES_ADMIN_CONTAINER" \
              --account-name "$STORAGE_ACCOUNT" \
              --auth-mode login
            echo "‚úÖ Container created: $CLOUDFLARE_PAGES_ADMIN_CONTAINER"
          else
            echo "‚úÖ Container exists: $CLOUDFLARE_PAGES_ADMIN_CONTAINER"
          fi

          # Create Cloudflare Pages Viewer container
          CLOUDFLARE_PAGES_VIEWER_CONTAINER="dculus-forms-cloudflare-pages-viewer-${ENV}-state"
          if ! az storage container show \
            --name "$CLOUDFLARE_PAGES_VIEWER_CONTAINER" \
            --account-name "$STORAGE_ACCOUNT" &>/dev/null; then
            echo "üì¶ Creating container: $CLOUDFLARE_PAGES_VIEWER_CONTAINER"
            az storage container create \
              --name "$CLOUDFLARE_PAGES_VIEWER_CONTAINER" \
              --account-name "$STORAGE_ACCOUNT" \
              --auth-mode login
            echo "‚úÖ Container created: $CLOUDFLARE_PAGES_VIEWER_CONTAINER"
          else
            echo "‚úÖ Container exists: $CLOUDFLARE_PAGES_VIEWER_CONTAINER"
          fi

          # Create Azure PostgreSQL container
          POSTGRES_CONTAINER="dculus-forms-postgres-${ENV}-state"
          if ! az storage container show \
            --name "$POSTGRES_CONTAINER" \
            --account-name "$STORAGE_ACCOUNT" &>/dev/null; then
            echo "üì¶ Creating container: $POSTGRES_CONTAINER"
            az storage container create \
              --name "$POSTGRES_CONTAINER" \
              --account-name "$STORAGE_ACCOUNT" \
              --auth-mode login
            echo "‚úÖ Container created: $POSTGRES_CONTAINER"
          else
            echo "‚úÖ Container exists: $POSTGRES_CONTAINER"
          fi

          # Create NeonDB container
          NEON_CONTAINER="dculus-forms-neon-${ENV}-state"
          if ! az storage container show \
            --name "$NEON_CONTAINER" \
            --account-name "$STORAGE_ACCOUNT" &>/dev/null; then
            echo "üì¶ Creating container: $NEON_CONTAINER"
            az storage container create \
              --name "$NEON_CONTAINER" \
              --account-name "$STORAGE_ACCOUNT" \
              --auth-mode login
            echo "‚úÖ Container created: $NEON_CONTAINER"
          else
            echo "‚úÖ Container exists: $NEON_CONTAINER"
          fi

  # ============================================================
  # PHASE 2: PRE-DEPLOYMENT VALIDATION
  # ============================================================

  check-docker-image:
    name: 2.1. Validate Docker Image Availability
    runs-on: ubuntu-latest
    needs: [determine-environment, setup-azure-backend]
    if: needs.determine-environment.outputs.deploy_azure == 'true'
    outputs:
      image_exists: ${{ steps.check-image.outputs.exists }}
      image_tag: ${{ steps.set-tag.outputs.tag }}
    steps:
      - name: Set image tag
        id: set-tag
        run: |
          TAG="${{ needs.determine-environment.outputs.release_tag }}"
          echo "tag=${TAG}" >> $GITHUB_OUTPUT
          echo "Using Docker image tag: ${TAG}"

      - name: Check if Docker image exists
        id: check-image
        run: |
          IMAGE_NAME="dculus/forms-backend"
          TAG="${{ steps.set-tag.outputs.tag }}"

          # Try to pull the image manifest (without silencing output to see errors)
          echo "Executing: docker manifest inspect ${IMAGE_NAME}:${TAG}"
          
          if docker manifest inspect "${IMAGE_NAME}:${TAG}"; then
            echo "‚úÖ Docker image exists: ${IMAGE_NAME}:${TAG}"
            echo "exists=true" >> $GITHUB_OUTPUT
          else
            echo "‚ùå Docker image does not exist or cannot be accessed: ${IMAGE_NAME}:${TAG}"
            echo "‚ö†Ô∏è  Please run the build.yml workflow with tag ${TAG} to build the image first"
            echo "exists=false" >> $GITHUB_OUTPUT
            exit 1
          fi

  # ============================================================
  # PHASE 3: DATABASE INFRASTRUCTURE
  # ============================================================

  terraform-postgres-deploy:
    name: 3.2. Deploy Azure PostgreSQL Infrastructure
    runs-on: ubuntu-latest
    needs: [determine-environment, setup-azure-backend]
    if: |
      always() && !cancelled() && !failure() &&
      needs.determine-environment.outputs.deploy_postgres == 'true'
    environment: ${{ needs.determine-environment.outputs.environment }}
    outputs:
      connection_string: ${{ steps.apply.outputs.connection_string }}
      server_name: ${{ steps.apply.outputs.server_name }}
      server_fqdn: ${{ steps.apply.outputs.server_fqdn }}
      database_name: ${{ steps.apply.outputs.database_name }}
      resource_group_name: ${{ steps.apply.outputs.resource_group_name }}
    defaults:
      run:
        working-directory: ${{ env.POSTGRES_TERRAFORM_DIR }}/environments/${{ needs.determine-environment.outputs.environment }}
    steps:
      - name: Checkout code
        uses: actions/checkout@v4
        with:
          path: dculus-forms

      - name: Azure Login (OIDC)
        uses: azure/login@v2
        with:
          client-id: ${{ secrets.AZURE_CLIENT_ID }}
          tenant-id: ${{ secrets.AZURE_TENANT_ID }}
          subscription-id: ${{ secrets.AZURE_SUBSCRIPTION_ID }}

      - name: Get Azure Storage Account Key
        id: get-storage-key
        run: |
          ACCOUNT_KEY=$(az storage account keys list \
            --resource-group dculus-global-terraform-assets-resource-grp \
            --account-name dculusterraformstates \
            --query '[0].value' -o tsv)
          echo "::add-mask::$ACCOUNT_KEY"
          echo "ARM_ACCESS_KEY=$ACCOUNT_KEY" >> $GITHUB_ENV

      - name: Setup Terraform
        uses: hashicorp/setup-terraform@v3
        with:
          terraform_version: ${{ env.TERRAFORM_VERSION }}

      - name: Copy shared Terraform files
        run: |
          cp ../../main.tf .
          cp ../../variables.tf .
          cp ../../outputs.tf .
          echo "‚úÖ Copied shared Terraform files"

      - name: Terraform Init
        env:
          TF_VAR_admin_password: ${{ secrets.POSTGRES_ADMIN_PASSWORD }}
        run: |
          terraform init \
            -backend-config="resource_group_name=dculus-global-terraform-assets-resource-grp" \
            -backend-config="storage_account_name=dculusterraformstates" \
            -backend-config="container_name=dculus-forms-postgres-${{ needs.determine-environment.outputs.environment }}-state" \
            -backend-config="key=terraform.tfstate"

      - name: Terraform Validate
        env:
          TF_VAR_admin_password: ${{ secrets.POSTGRES_ADMIN_PASSWORD }}
        run: terraform validate

      - name: Terraform Plan
        env:
          TF_VAR_admin_password: ${{ secrets.POSTGRES_ADMIN_PASSWORD }}
        run: terraform plan -out=tfplan

      - name: Terraform Apply
        id: apply
        if: needs.determine-environment.outputs.should_deploy == 'true'
        env:
          TF_VAR_admin_password: ${{ secrets.POSTGRES_ADMIN_PASSWORD }}
        run: |
          terraform apply -auto-approve tfplan

          # Capture outputs
          CONNECTION_STRING=$(terraform output -raw connection_string)
          echo "::add-mask::$CONNECTION_STRING"
          echo "connection_string=$CONNECTION_STRING" >> $GITHUB_OUTPUT
          echo "server_name=$(terraform output -raw server_name)" >> $GITHUB_OUTPUT
          echo "server_fqdn=$(terraform output -raw server_fqdn)" >> $GITHUB_OUTPUT
          echo "database_name=$(terraform output -raw database_name)" >> $GITHUB_OUTPUT
          echo "server_fqdn=$(terraform output -raw server_fqdn)" >> $GITHUB_OUTPUT
          echo "database_name=$(terraform output -raw database_name)" >> $GITHUB_OUTPUT
          echo "resource_group_name=$(terraform output -raw resource_group_name)" >> $GITHUB_OUTPUT

  terraform-neon-deploy:
    name: 3.3. Deploy NeonDB Infrastructure
    runs-on: ubuntu-latest
    needs: [determine-environment, setup-azure-backend]
    if: |
      always() && !cancelled() && !failure() &&
      needs.determine-environment.outputs.deploy_postgres == 'true'
    environment: ${{ needs.determine-environment.outputs.environment }}
    outputs:
      connection_string: ${{ steps.apply.outputs.connection_string }}
      database_host: ${{ steps.apply.outputs.database_host }}
    defaults:
      run:
        working-directory: dculus-forms/infrastructure/multi-cloud/terraform/neon-postgres/environments/${{ needs.determine-environment.outputs.environment }}
    steps:
      - name: Checkout code
        uses: actions/checkout@v4
        with:
          path: dculus-forms

      - name: Azure Login (OIDC)
        uses: azure/login@v2
        with:
          client-id: ${{ secrets.AZURE_CLIENT_ID }}
          tenant-id: ${{ secrets.AZURE_TENANT_ID }}
          subscription-id: ${{ secrets.AZURE_SUBSCRIPTION_ID }}

      - name: Get Azure Storage Account Key
        id: get-storage-key
        run: |
          ACCOUNT_KEY=$(az storage account keys list \
            --resource-group dculus-global-terraform-assets-resource-grp \
            --account-name dculusterraformstates \
            --query '[0].value' -o tsv)
          echo "::add-mask::$ACCOUNT_KEY"
          echo "ARM_ACCESS_KEY=$ACCOUNT_KEY" >> $GITHUB_ENV

      - name: Setup Terraform
        uses: hashicorp/setup-terraform@v3
        with:
          terraform_version: ${{ env.TERRAFORM_VERSION }}

      - name: Copy shared Terraform files
        run: |
          cp ../../main.tf .
          cp ../../variables.tf .
          cp ../../outputs.tf .
          cp ../../versions.tf .
          echo "‚úÖ Copied shared Terraform files"

      - name: Terraform Init
        env:
          TF_VAR_neon_api_key: ${{ secrets.NEON_API_KEY }}
        run: |
          terraform init \
            -backend-config="resource_group_name=dculus-global-terraform-assets-resource-grp" \
            -backend-config="storage_account_name=dculusterraformstates" \
            -backend-config="container_name=dculus-forms-neon-${{ needs.determine-environment.outputs.environment }}-state" \
            -backend-config="key=terraform.tfstate"

      - name: Terraform Validate
        env:
          TF_VAR_neon_api_key: ${{ secrets.NEON_API_KEY }}
        run: terraform validate

      - name: Terraform Plan
        env:
          TF_VAR_neon_api_key: ${{ secrets.NEON_API_KEY }}
        run: terraform plan -out=tfplan

      - name: Terraform Apply
        id: apply
        if: needs.determine-environment.outputs.should_deploy == 'true'
        env:
          TF_VAR_neon_api_key: ${{ secrets.NEON_API_KEY }}
        run: |
          terraform apply -auto-approve tfplan

          # Capture outputs
          CONNECTION_STRING=$(terraform output -raw connection_string)
          echo "::add-mask::$CONNECTION_STRING"
          echo "connection_string=$CONNECTION_STRING" >> $GITHUB_OUTPUT
          echo "database_host=$(terraform output -raw database_host)" >> $GITHUB_OUTPUT

  # ============================================================
  # PHASE 4: CORE INFRASTRUCTURE (Storage + Backend)
  # ============================================================

  terraform-infrastructure-deploy:
    name: 4.1. Deploy Core Infrastructure (R2 Storage + Azure Container Apps)
    runs-on: ubuntu-latest
    needs: [determine-environment, setup-azure-backend, check-docker-image, terraform-neon-deploy]
    if: |
      always() && !cancelled() && !failure() &&
      (needs.determine-environment.outputs.deploy_cloudflare == 'true' ||
       needs.determine-environment.outputs.deploy_azure == 'true')
    environment: ${{ needs.determine-environment.outputs.environment }}
    outputs:
      # Cloudflare outputs
      private_bucket: ${{ steps.cloudflare-outputs.outputs.private_bucket }}
      public_bucket: ${{ steps.cloudflare-outputs.outputs.public_bucket }}
      public_cdn_url: ${{ steps.cloudflare-outputs.outputs.public_cdn_url }}
      # Azure outputs
      backend_url: ${{ steps.azure-outputs.outputs.backend_url }}
      graphql_endpoint: ${{ steps.azure-outputs.outputs.graphql_endpoint }}
      health_endpoint: ${{ steps.azure-outputs.outputs.health_endpoint }}
      container_app_name: ${{ steps.azure-outputs.outputs.container_app_name }}
      backend_fqdn: ${{ steps.azure-outputs.outputs.backend_fqdn }}
    steps:
      - name: Checkout code
        uses: actions/checkout@v4
        with:
          path: dculus-forms

      - name: Azure Login (OIDC)
        uses: azure/login@v2
        with:
          client-id: ${{ secrets.AZURE_CLIENT_ID }}
          tenant-id: ${{ secrets.AZURE_TENANT_ID }}
          subscription-id: ${{ secrets.AZURE_SUBSCRIPTION_ID }}

      - name: Get Azure Storage Account Key
        id: get-storage-key
        run: |
          ACCOUNT_KEY=$(az storage account keys list \
            --resource-group dculus-global-terraform-assets-resource-grp \
            --account-name dculusterraformstates \
            --query '[0].value' -o tsv)
          echo "::add-mask::$ACCOUNT_KEY"
          echo "ARM_ACCESS_KEY=$ACCOUNT_KEY" >> $GITHUB_ENV

      - name: Setup Terraform
        uses: hashicorp/setup-terraform@v3
        with:
          terraform_version: ${{ env.TERRAFORM_VERSION }}
          terraform_wrapper: false

      # ==================== CLOUDFLARE R2 DEPLOYMENT ====================
      - name: Deploy Cloudflare R2
        id: cloudflare-deploy
        if: needs.determine-environment.outputs.deploy_cloudflare == 'true'
        working-directory: dculus-forms/infrastructure/multi-cloud/terraform/cloudflare/environments/${{ needs.determine-environment.outputs.environment }}
        env:
          CLOUDFLARE_API_TOKEN: ${{ secrets.CLOUDFLARE_API_TOKEN }}
          TF_VAR_cloudflare_account_id: ${{ secrets.CLOUDFLARE_ACCOUNT_ID }}
          TF_VAR_cloudflare_zone_id: ${{ secrets.CLOUDFLARE_ZONE_ID }}
          TF_VAR_cloudflare_api_token: ${{ secrets.CLOUDFLARE_API_TOKEN }}
        run: |
          # Copy shared Terraform files
          cp ../../main.tf .
          cp ../../variables.tf .
          cp ../../r2-buckets.tf .
          cp ../../r2-custom-domains.tf .
          cp ../../r2-api-token.tf .
          cp ../../outputs.tf .

          # Initialize Terraform
          terraform init \
            -backend-config="resource_group_name=dculus-global-terraform-assets-resource-grp" \
            -backend-config="storage_account_name=dculusterraformstates" \
            -backend-config="container_name=dculus-forms-cloudflare-r2-${{ needs.determine-environment.outputs.environment }}-state" \
            -backend-config="key=terraform.tfstate"

          # Validate
          terraform validate

          # Plan
          terraform plan

          # Apply
          terraform apply -auto-approve \
            -var="cloudflare_account_id=${{ secrets.CLOUDFLARE_ACCOUNT_ID }}" \
            -var="cloudflare_api_token=${{ secrets.CLOUDFLARE_API_TOKEN }}" \
            -var="cloudflare_zone_id=${{ secrets.CLOUDFLARE_ZONE_ID }}"

          # Capture outputs to environment variables (stays within job)
          echo "R2_PRIVATE_BUCKET=$(terraform output -raw private_bucket_name)" >> $GITHUB_ENV
          echo "R2_PUBLIC_BUCKET=$(terraform output -raw public_bucket_name)" >> $GITHUB_ENV
          echo "R2_PUBLIC_CDN_URL=$(terraform output -raw public_cdn_url)" >> $GITHUB_ENV
          echo "R2_ACCESS_KEY_ID=$(terraform output -raw r2_access_key_id)" >> $GITHUB_ENV
          echo "R2_SECRET_ACCESS_KEY=$(terraform output -raw r2_secret_access_key)" >> $GITHUB_ENV
          echo "R2_ENDPOINT=https://${{ secrets.CLOUDFLARE_ACCOUNT_ID }}.r2.cloudflarestorage.com" >> $GITHUB_ENV

          echo "‚úÖ Cloudflare R2 deployed successfully"

      - name: Set Cloudflare outputs
        id: cloudflare-outputs
        if: needs.determine-environment.outputs.deploy_cloudflare == 'true'
        run: |
          echo "private_bucket=${{ env.R2_PRIVATE_BUCKET }}" >> $GITHUB_OUTPUT
          echo "public_bucket=${{ env.R2_PUBLIC_BUCKET }}" >> $GITHUB_OUTPUT
          echo "public_cdn_url=${{ env.R2_PUBLIC_CDN_URL }}" >> $GITHUB_OUTPUT

      # ==================== AZURE CONTAINER APPS DEPLOYMENT ====================
      - name: Retrieve Neon DB connection string from Terraform state
        id: get-postgres-connection
        if: needs.determine-environment.outputs.deploy_azure == 'true'
        working-directory: dculus-forms/infrastructure/multi-cloud/terraform/neon-postgres/environments/${{ needs.determine-environment.outputs.environment }}
        env:
          TF_VAR_neon_api_key: ${{ secrets.NEON_API_KEY }}
        run: |
          # If Neon DB was deployed in this run, use its output
          if [ -n "${{ needs.terraform-neon-deploy.outputs.connection_string }}" ]; then
            echo "Using Neon DB connection string from current deployment"
            echo "connection_string=${{ needs.terraform-neon-deploy.outputs.connection_string }}" >> $GITHUB_OUTPUT
            exit 0
          fi

          # Otherwise, retrieve from existing Terraform state
          echo "Retrieving Neon DB connection string from Terraform state..."

          # Copy shared Terraform files (needed for state access)
          cp ../../main.tf .
          cp ../../variables.tf .
          cp ../../outputs.tf .
          cp ../../versions.tf .

          # Initialize Terraform to access remote state
          terraform init \
            -backend-config="resource_group_name=dculus-global-terraform-assets-resource-grp" \
            -backend-config="storage_account_name=dculusterraformstates" \
            -backend-config="container_name=dculus-forms-neon-${{ needs.determine-environment.outputs.environment }}-state" \
            -backend-config="key=terraform.tfstate"

          # Retrieve connection string from state
          CONNECTION_STRING=$(terraform output -raw connection_string 2>/dev/null || echo "")

          if [ -z "$CONNECTION_STRING" ]; then
            echo "‚ùå Error: Could not retrieve Neon DB connection string from Terraform state"
            echo "üí° Tip: Ensure Neon DB has been deployed (deploy_postgres=true)"
            exit 1
          fi

          echo "‚úÖ Retrieved Neon DB connection string from existing infrastructure"
          echo "::add-mask::$CONNECTION_STRING"
          echo "connection_string=$CONNECTION_STRING" >> $GITHUB_OUTPUT

      - name: Deploy Azure Container Apps
        id: azure-deploy
        if: needs.determine-environment.outputs.deploy_azure == 'true'
        working-directory: dculus-forms/infrastructure/multi-cloud/terraform/azure/environments/${{ needs.determine-environment.outputs.environment }}
        env:
          TF_VAR_postgres_connection_string: ${{ steps.get-postgres-connection.outputs.connection_string }}
          TF_VAR_better_auth_secret: ${{ secrets.BETTER_AUTH_SECRET }}
          TF_VAR_public_s3_access_key: ${{ env.R2_ACCESS_KEY_ID }}
          TF_VAR_public_s3_secret_key: ${{ env.R2_SECRET_ACCESS_KEY }}
          TF_VAR_public_s3_endpoint: ${{ env.R2_ENDPOINT }}
          TF_VAR_public_s3_cdn_url: ${{ env.R2_PUBLIC_CDN_URL }}
          TF_VAR_private_s3_bucket_name: ${{ env.R2_PRIVATE_BUCKET }}
          TF_VAR_public_s3_bucket_name: ${{ env.R2_PUBLIC_BUCKET }}
          TF_VAR_cors_origins: ${{ secrets.CORS_ORIGINS }}
          TF_VAR_container_image_tag: ${{ needs.check-docker-image.outputs.image_tag }}
          TF_VAR_admin_email: ${{ secrets.ADMIN_EMAIL }}
          TF_VAR_admin_password: ${{ secrets.ADMIN_PASSWORD }}
          TF_VAR_admin_name: ${{ secrets.ADMIN_NAME }}
          TF_VAR_email_host: ${{ secrets.EMAIL_HOST }}
          TF_VAR_email_port: ${{ secrets.EMAIL_PORT }}
          TF_VAR_email_user: ${{ secrets.EMAIL_USER }}
          TF_VAR_email_password: ${{ secrets.EMAIL_PASSWORD }}
          TF_VAR_email_from: ${{ secrets.EMAIL_FROM }}
          TF_VAR_chargebee_site: ${{ secrets.CHARGEBEE_SITE }}
          TF_VAR_chargebee_api_key: ${{ secrets.CHARGEBEE_API_KEY }}
          TF_VAR_sentry_dsn: ${{ secrets.SENTRY_DSN }}
          TF_VAR_run_seed: true
        run: |
          # Copy shared Terraform files
          cp ../../main.tf .
          cp ../../variables.tf .
          cp ../../outputs.tf .

          # Initialize Terraform
          terraform init \
            -backend-config="resource_group_name=dculus-global-terraform-assets-resource-grp" \
            -backend-config="storage_account_name=dculusterraformstates" \
            -backend-config="container_name=dculus-forms-azure-backend-${{ needs.determine-environment.outputs.environment }}-state" \
            -backend-config="key=terraform.tfstate"

          # Clean orphaned resources from state
          ENV="${{ needs.determine-environment.outputs.environment }}"
          RESOURCE_GROUP="dculus-forms-${ENV}-rg"
          CONTAINER_APP_NAME="dculus-forms-${ENV}-backend"

          if ! az containerapp show --name "$CONTAINER_APP_NAME" --resource-group "$RESOURCE_GROUP" &>/dev/null; then
            if terraform state list | grep -q "azurerm_container_app.backend"; then
              terraform state rm azurerm_container_app.backend || true
            fi
          fi

          # Validate
          terraform validate

          # Plan
          IMAGE_TAG="${TF_VAR_container_image_tag}"
          terraform plan -out=tfplan -var="container_image_tag=${IMAGE_TAG}"

          # Apply
          if [ "${{ needs.determine-environment.outputs.should_deploy }}" = "true" ]; then
            terraform apply -auto-approve tfplan

            # Capture outputs
            echo "BACKEND_URL=$(terraform output -raw backend_url)" >> $GITHUB_ENV
            echo "BACKEND_FQDN=$(terraform output -raw backend_fqdn)" >> $GITHUB_ENV
            echo "CONTAINER_APP_NAME=$(terraform output -json deployment_info | jq -r '.container_app_name')" >> $GITHUB_ENV

            echo "‚úÖ Azure Container Apps deployed successfully"
          fi

      - name: Set Azure outputs
        id: azure-outputs
        if: needs.determine-environment.outputs.deploy_azure == 'true' && needs.determine-environment.outputs.should_deploy == 'true'
        run: |
          echo "backend_url=${{ env.BACKEND_URL }}" >> $GITHUB_OUTPUT
          echo "backend_fqdn=${{ env.BACKEND_FQDN }}" >> $GITHUB_OUTPUT
          echo "graphql_endpoint=${{ env.BACKEND_URL }}/graphql" >> $GITHUB_OUTPUT
          echo "health_endpoint=${{ env.BACKEND_URL }}/health" >> $GITHUB_OUTPUT
          echo "container_app_name=${{ env.CONTAINER_APP_NAME }}" >> $GITHUB_OUTPUT

  # ============================================================
  # PHASE 5: DOMAIN CONFIGURATION (Backend + Frontend in Parallel)
  # ============================================================

  terraform-cloudflare-service-domain:
    name: 5.1. Configure Backend Service Domain DNS
    runs-on: ubuntu-latest
    needs: [determine-environment, setup-azure-backend, terraform-infrastructure-deploy]
    if: |
      always() && !cancelled() && !failure() &&
      needs.determine-environment.outputs.should_deploy == 'true' &&
      needs.determine-environment.outputs.deploy_cloudflare == 'true' &&
      needs.determine-environment.outputs.deploy_azure == 'true' &&
      needs.terraform-infrastructure-deploy.result == 'success'
    environment: ${{ needs.determine-environment.outputs.environment }}
    outputs:
      service_domain: ${{ steps.apply.outputs.service_domain }}
      target_backend_fqdn: ${{ steps.apply.outputs.target_backend_fqdn }}
    defaults:
      run:
        working-directory: ${{ env.CLOUDFLARE_SERVICE_TERRAFORM_DIR }}/environments/${{ needs.determine-environment.outputs.environment }}
    env:
      TF_VAR_cloudflare_zone_id: ${{ secrets.CLOUDFLARE_ZONE_ID }}
      TF_VAR_cloudflare_api_token: ${{ secrets.CLOUDFLARE_API_TOKEN }}
      TF_VAR_backend_fqdn: ${{ needs.terraform-infrastructure-deploy.outputs.backend_fqdn }}
    steps:
      - name: Checkout code
        uses: actions/checkout@v4
        with:
          path: dculus-forms

      - name: Azure Login (OIDC)
        uses: azure/login@v2
        with:
          client-id: ${{ secrets.AZURE_CLIENT_ID }}
          tenant-id: ${{ secrets.AZURE_TENANT_ID }}
          subscription-id: ${{ secrets.AZURE_SUBSCRIPTION_ID }}

      - name: Get Azure Storage Account Key
        id: get-storage-key
        run: |
          ACCOUNT_KEY=$(az storage account keys list \
            --resource-group dculus-global-terraform-assets-resource-grp \
            --account-name dculusterraformstates \
            --query '[0].value' -o tsv)
          echo "::add-mask::$ACCOUNT_KEY"
          echo "ARM_ACCESS_KEY=$ACCOUNT_KEY" >> $GITHUB_ENV

      - name: Setup Terraform
        uses: hashicorp/setup-terraform@v3
        with:
          terraform_version: ${{ env.TERRAFORM_VERSION }}
          terraform_wrapper: false

      - name: Validate backend FQDN
        run: |
          if [ -z "${{ needs.terraform-infrastructure-deploy.outputs.backend_fqdn }}" ]; then
            echo "‚ùå Azure backend FQDN output is empty. Aborting DNS update."
            exit 1
          fi
          echo "üîó Updating DNS for backend FQDN: ${{ needs.terraform-infrastructure-deploy.outputs.backend_fqdn }}"

      - name: Copy shared Terraform files
        run: |
          cp ../../main.tf .
          cp ../../variables.tf .
          cp ../../outputs.tf .
          echo "‚úÖ Copied shared Terraform files"

      - name: Terraform Init
        run: |
          terraform init \
            -backend-config="resource_group_name=dculus-global-terraform-assets-resource-grp" \
            -backend-config="storage_account_name=dculusterraformstates" \
            -backend-config="container_name=dculus-forms-cloudflare-services-${{ needs.determine-environment.outputs.environment }}-state" \
            -backend-config="key=terraform.tfstate"

      - name: Terraform Validate
        run: terraform validate

      - name: Terraform Plan
        run: terraform plan -out=tfplan

      - name: Terraform Apply
        id: apply
        run: |
          terraform apply -auto-approve tfplan

          echo "service_domain=$(terraform output -raw service_domain)" >> $GITHUB_OUTPUT
          echo "target_backend_fqdn=$(terraform output -raw target_backend_fqdn)" >> $GITHUB_OUTPUT

  terraform-cloudflare-pages:
    name: 5.2. Setup Pages Infrastructure & Domain (form-app)
    runs-on: ubuntu-latest
    needs: [determine-environment, setup-azure-backend, terraform-infrastructure-deploy]
    if: |
      always() && !cancelled() && !failure() &&
      needs.determine-environment.outputs.should_deploy == 'true' &&
      needs.determine-environment.outputs.deploy_cloudflare == 'true' &&
      needs.terraform-infrastructure-deploy.result == 'success'
    environment: ${{ needs.determine-environment.outputs.environment }}
    outputs:
      pages_project_name: ${{ steps.apply.outputs.pages_project_name }}
      pages_url: ${{ steps.apply.outputs.pages_url }}
      custom_domain: ${{ steps.apply.outputs.custom_domain }}
    defaults:
      run:
        working-directory: ${{ env.CLOUDFLARE_PAGES_TERRAFORM_DIR }}/environments/${{ needs.determine-environment.outputs.environment }}
    env:
      CLOUDFLARE_API_TOKEN: ${{ secrets.CLOUDFLARE_API_TOKEN }}
      TF_VAR_cloudflare_account_id: ${{ secrets.CLOUDFLARE_ACCOUNT_ID }}
      TF_VAR_cloudflare_api_token: ${{ secrets.CLOUDFLARE_API_TOKEN }}
      TF_VAR_cloudflare_zone_id: ${{ secrets.CLOUDFLARE_ZONE_ID }}
      TF_VAR_environment: ${{ needs.determine-environment.outputs.environment }}
    steps:
      - name: Checkout code
        uses: actions/checkout@v4
        with:
          path: dculus-forms

      - name: Azure Login (OIDC)
        uses: azure/login@v2
        with:
          client-id: ${{ secrets.AZURE_CLIENT_ID }}
          tenant-id: ${{ secrets.AZURE_TENANT_ID }}
          subscription-id: ${{ secrets.AZURE_SUBSCRIPTION_ID }}

      - name: Get Azure Storage Account Key
        id: get-storage-key
        run: |
          ACCOUNT_KEY=$(az storage account keys list \
            --resource-group dculus-global-terraform-assets-resource-grp \
            --account-name dculusterraformstates \
            --query '[0].value' -o tsv)
          echo "::add-mask::$ACCOUNT_KEY"
          echo "ARM_ACCESS_KEY=$ACCOUNT_KEY" >> $GITHUB_ENV

      - name: Setup Terraform
        uses: hashicorp/setup-terraform@v3
        with:
          terraform_version: ${{ env.TERRAFORM_VERSION }}
          terraform_wrapper: false

      - name: Copy shared Terraform files
        run: |
          cp ../../main.tf .
          cp ../../variables.tf .
          cp ../../outputs.tf .
          cp ../../cloudflare-pages-domain.tf .
          echo "‚úÖ Copied shared Terraform files"

      - name: Terraform Init
        run: |
          terraform init \
            -backend-config="resource_group_name=dculus-global-terraform-assets-resource-grp" \
            -backend-config="storage_account_name=dculusterraformstates" \
            -backend-config="container_name=dculus-forms-cloudflare-pages-${{ needs.determine-environment.outputs.environment }}-state" \
            -backend-config="key=terraform.tfstate"

      - name: Terraform Validate
        run: terraform validate

      - name: Terraform Plan
        run: terraform plan -out=tfplan

      - name: Terraform Apply
        id: apply
        run: |
          terraform apply -auto-approve tfplan

          echo "pages_project_name=$(terraform output -raw pages_project_name)" >> $GITHUB_OUTPUT
          echo "pages_url=$(terraform output -raw pages_url)" >> $GITHUB_OUTPUT
          echo "custom_domain=$(terraform output -raw custom_domain)" >> $GITHUB_OUTPUT

          echo "‚úÖ Cloudflare Pages project created: $(terraform output -raw pages_project_name)"
          echo "üìç Custom domain: $(terraform output -raw custom_domain)"

  # ============================================================
  # PHASE 6: APPLICATION DEPLOYMENT (All Frontends)
  # ============================================================

  deploy-cloudflare-pages-form-app:
    name: 6.1. Build & Deploy Frontend (form-app)
    runs-on: ubuntu-latest
    needs:
      - determine-environment
      - terraform-infrastructure-deploy
      - terraform-cloudflare-service-domain
      - terraform-cloudflare-pages
      - terraform-cloudflare-pages-viewer
    if: |
      always() && !cancelled() && !failure() &&
      needs.determine-environment.outputs.should_deploy == 'true' &&
      needs.determine-environment.outputs.deploy_cloudflare == 'true' &&
      needs.terraform-cloudflare-service-domain.result == 'success' &&
      needs.terraform-cloudflare-pages.result == 'success' &&
      needs.terraform-cloudflare-pages-viewer.result == 'success'
    environment: ${{ needs.determine-environment.outputs.environment }}
    steps:
      - name: Prepare release metadata
        run: |
          echo "RELEASE_TAG=${{ needs.determine-environment.outputs.release_tag }}" >> $GITHUB_ENV
          echo "RELEASE_COMMIT=${{ needs.determine-environment.outputs.release_commit }}" >> $GITHUB_ENV
          echo "üì¶ Deploying tag: ${{ needs.determine-environment.outputs.release_tag }}"

      - name: Checkout source code
        uses: actions/checkout@v4
        with:
          ref: ${{ needs.determine-environment.outputs.release_commit }}
          path: source

      - name: Setup Node.js
        uses: actions/setup-node@v4
        with:
          node-version: '20'

      - name: Setup pnpm
        uses: pnpm/action-setup@v2
        with:
          version: 8

      - name: Install dependencies
        working-directory: ./source
        run: |
          echo "üì¶ Installing dependencies..."
          pnpm install --frozen-lockfile
          echo "‚úÖ Dependencies installed"

      - name: Build shared packages
        working-directory: ./source
        run: |
          echo "üî® Building shared packages..."
          pnpm --filter @dculus/types build
          pnpm --filter @dculus/utils build
          pnpm --filter @dculus/ui build
          echo "‚úÖ Shared packages built"

      - name: Build form-app with environment-specific variables
        working-directory: ./source
        env:
          VITE_GRAPHQL_URL: https://${{ needs.terraform-cloudflare-service-domain.outputs.service_domain }}/graphql
          VITE_API_URL: https://${{ needs.terraform-cloudflare-service-domain.outputs.service_domain }}
          VITE_CDN_ENDPOINT: ${{ needs.terraform-infrastructure-deploy.outputs.public_cdn_url }}
          VITE_PIXABAY_API_KEY: ${{ secrets.PIXABAY_API_KEY }}
          VITE_FORM_VIEWER_URL: ${{ needs.terraform-cloudflare-pages-viewer.outputs.custom_domain }}
        run: |
          echo "üî® Building form-app for environment: ${{ needs.determine-environment.outputs.environment }}"
          echo "Backend URL: $VITE_API_URL"
          echo "GraphQL URL: $VITE_GRAPHQL_URL"
          echo "CDN Endpoint: $VITE_CDN_ENDPOINT"
          echo "Form Viewer URL: $VITE_FORM_VIEWER_URL"

          pnpm --filter form-app build

          echo "‚úÖ form-app build completed"
          ls -la apps/form-app/dist/

      - name: Install wrangler
        run: npm install -g wrangler

      - name: Deploy to Cloudflare Pages
        working-directory: ./source
        env:
          CLOUDFLARE_API_TOKEN: ${{ secrets.CLOUDFLARE_API_TOKEN }}
          CLOUDFLARE_ACCOUNT_ID: ${{ secrets.CLOUDFLARE_ACCOUNT_ID }}
          RELEASE_TAG: ${{ needs.determine-environment.outputs.release_tag }}
          RELEASE_COMMIT: ${{ needs.determine-environment.outputs.release_commit }}
        run: |
          echo "üöÄ Deploying to Cloudflare Pages..."
          echo "Project: form-app-${{ needs.determine-environment.outputs.environment }}"

          wrangler pages deploy apps/form-app/dist \
            --project-name=form-app-${{ needs.determine-environment.outputs.environment }} \
            --branch=main \
            --commit-hash=${RELEASE_COMMIT} \
            --commit-message="Deploy release ${RELEASE_TAG} to ${{ needs.determine-environment.outputs.environment }}"

          echo "‚úÖ Deployment completed"

      - name: Purge Cloudflare cache
        env:
          CLOUDFLARE_API_TOKEN: ${{ secrets.CLOUDFLARE_API_TOKEN }}
          CLOUDFLARE_ZONE_ID: ${{ secrets.CLOUDFLARE_ZONE_ID }}
        run: |
          echo "üîÑ Purging Cloudflare cache for immediate visibility..."
          
          PURGE_RESPONSE=$(curl -X POST "https://api.cloudflare.com/client/v4/zones/${CLOUDFLARE_ZONE_ID}/purge_cache" \
            -H "Authorization: Bearer ${CLOUDFLARE_API_TOKEN}" \
            -H "Content-Type: application/json" \
            --data '{"purge_everything":true}' \
            --silent \
            --show-error)
          
          if echo "$PURGE_RESPONSE" | grep -q '"success":true'; then
            echo "‚úÖ Cache purged successfully"
            echo "üí° Changes should be visible immediately without CDN cache delays"
          else
            echo "‚ö†Ô∏è Cache purge may have failed, but deployment was successful"
            echo "Response: $PURGE_RESPONSE"
          fi

      - name: Health check deployment
        run: |
          CUSTOM_DOMAIN="${{ needs.terraform-cloudflare-pages.outputs.custom_domain }}"
          echo "üîç Checking deployment at: $CUSTOM_DOMAIN"

          # Wait for DNS propagation and deployment
          echo "‚è≥ Waiting 60 seconds for DNS propagation..."
          sleep 60

          # Retry health check up to 5 times
          MAX_RETRIES=5
          RETRY_COUNT=0

          while [ $RETRY_COUNT -lt $MAX_RETRIES ]; do
            HTTP_CODE=$(curl -s -o /dev/null -w "%{http_code}" -L "$CUSTOM_DOMAIN" || echo "000")

            if [ "$HTTP_CODE" = "200" ]; then
              echo "‚úÖ Health check passed! (HTTP $HTTP_CODE)"
              echo "üåê form-app is live at: $CUSTOM_DOMAIN"
              exit 0
            else
              RETRY_COUNT=$((RETRY_COUNT + 1))
              echo "‚ö†Ô∏è Health check attempt $RETRY_COUNT/$MAX_RETRIES failed (HTTP $HTTP_CODE)"

              if [ $RETRY_COUNT -lt $MAX_RETRIES ]; then
                echo "‚è≥ Waiting 30 seconds before retry..."
                sleep 30
              fi
            fi
          done

          echo "‚ùå Health check failed after $MAX_RETRIES attempts"
          echo "üí° Check Cloudflare Pages dashboard: https://dash.cloudflare.com/${{ secrets.CLOUDFLARE_ACCOUNT_ID }}/pages/view/form-app-${{ needs.determine-environment.outputs.environment }}"
          exit 1

      - name: Deployment summary
        if: success()
        run: |
          echo "‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ"
          echo "‚úÖ form-app Deployment Successful"
          echo "‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ"
          echo ""
          echo "üì¶ Release: ${{ env.RELEASE_TAG }}"
          echo "üåç Environment: ${{ needs.determine-environment.outputs.environment }}"
          echo "üåê URL: ${{ needs.terraform-cloudflare-pages.outputs.custom_domain }}"
          echo "üìä Backend: https://${{ needs.terraform-cloudflare-service-domain.outputs.service_domain }}"
          echo ""
          echo "‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ"

  terraform-cloudflare-pages-admin:
    name: 5.3. Setup Pages Infrastructure & Domain (admin-app)
    runs-on: ubuntu-latest
    needs: [determine-environment, setup-azure-backend, terraform-infrastructure-deploy]
    if: |
      always() && !cancelled() && !failure() &&
      needs.determine-environment.outputs.should_deploy == 'true' &&
      needs.determine-environment.outputs.deploy_cloudflare == 'true' &&
      needs.terraform-infrastructure-deploy.result == 'success'
    environment: ${{ needs.determine-environment.outputs.environment }}
    outputs:
      pages_project_name: ${{ steps.apply.outputs.pages_project_name }}
      pages_url: ${{ steps.apply.outputs.pages_url }}
      custom_domain: ${{ steps.apply.outputs.custom_domain }}
    defaults:
      run:
        working-directory: ${{ env.CLOUDFLARE_PAGES_ADMIN_TERRAFORM_DIR }}/environments/${{ needs.determine-environment.outputs.environment }}
    env:
      CLOUDFLARE_API_TOKEN: ${{ secrets.CLOUDFLARE_API_TOKEN }}
      TF_VAR_cloudflare_account_id: ${{ secrets.CLOUDFLARE_ACCOUNT_ID }}
      TF_VAR_cloudflare_api_token: ${{ secrets.CLOUDFLARE_API_TOKEN }}
      TF_VAR_cloudflare_zone_id: ${{ secrets.CLOUDFLARE_ZONE_ID }}
      TF_VAR_environment: ${{ needs.determine-environment.outputs.environment }}
    steps:
      - name: Checkout code
        uses: actions/checkout@v4
        with:
          path: dculus-forms

      - name: Azure Login (OIDC)
        uses: azure/login@v2
        with:
          client-id: ${{ secrets.AZURE_CLIENT_ID }}
          tenant-id: ${{ secrets.AZURE_TENANT_ID }}
          subscription-id: ${{ secrets.AZURE_SUBSCRIPTION_ID }}

      - name: Get Azure Storage Account Key
        id: get-storage-key
        run: |
          ACCOUNT_KEY=$(az storage account keys list \
            --resource-group dculus-global-terraform-assets-resource-grp \
            --account-name dculusterraformstates \
            --query '[0].value' -o tsv)
          echo "::add-mask::$ACCOUNT_KEY"
          echo "ARM_ACCESS_KEY=$ACCOUNT_KEY" >> $GITHUB_ENV

      - name: Setup Terraform
        uses: hashicorp/setup-terraform@v3
        with:
          terraform_version: ${{ env.TERRAFORM_VERSION }}
          terraform_wrapper: false

      - name: Copy shared Terraform files
        run: |
          cp ../../main.tf .
          cp ../../variables.tf .
          cp ../../outputs.tf .
          cp ../../cloudflare-pages-domain.tf .
          echo "‚úÖ Copied shared Terraform files"

      - name: Terraform Init
        run: |
          terraform init \
            -backend-config="resource_group_name=dculus-global-terraform-assets-resource-grp" \
            -backend-config="storage_account_name=dculusterraformstates" \
            -backend-config="container_name=dculus-forms-cloudflare-pages-admin-${{ needs.determine-environment.outputs.environment }}-state" \
            -backend-config="key=terraform.tfstate"

      - name: Terraform Validate
        run: terraform validate

      - name: Terraform Plan
        run: terraform plan -out=tfplan

      - name: Terraform Apply
        id: apply
        run: |
          terraform apply -auto-approve tfplan

          echo "pages_project_name=$(terraform output -raw pages_project_name)" >> $GITHUB_OUTPUT
          echo "pages_url=$(terraform output -raw pages_url)" >> $GITHUB_OUTPUT
          echo "custom_domain=$(terraform output -raw custom_domain)" >> $GITHUB_OUTPUT

          echo "‚úÖ Cloudflare Pages project created: $(terraform output -raw pages_project_name)"
          echo "üìç Custom domain: $(terraform output -raw custom_domain)"

  deploy-cloudflare-pages-admin-app:
    name: 6.2. Build & Deploy Frontend (admin-app)
    runs-on: ubuntu-latest
    needs:
      - determine-environment
      - terraform-infrastructure-deploy
      - terraform-cloudflare-service-domain
      - terraform-cloudflare-pages-admin
    if: |
      always() && !cancelled() && !failure() &&
      needs.determine-environment.outputs.should_deploy == 'true' &&
      needs.determine-environment.outputs.deploy_cloudflare == 'true' &&
      needs.terraform-cloudflare-service-domain.result == 'success' &&
      needs.terraform-cloudflare-pages-admin.result == 'success'
    environment: ${{ needs.determine-environment.outputs.environment }}
    steps:
      - name: Prepare release metadata
        run: |
          echo "RELEASE_TAG=${{ needs.determine-environment.outputs.release_tag }}" >> $GITHUB_ENV
          echo "RELEASE_COMMIT=${{ needs.determine-environment.outputs.release_commit }}" >> $GITHUB_ENV
          echo "üì¶ Deploying tag: ${{ needs.determine-environment.outputs.release_tag }}"

      - name: Checkout source code
        uses: actions/checkout@v4
        with:
          ref: ${{ needs.determine-environment.outputs.release_commit }}
          path: source

      - name: Setup Node.js
        uses: actions/setup-node@v4
        with:
          node-version: '20'

      - name: Setup pnpm
        uses: pnpm/action-setup@v2
        with:
          version: 8

      - name: Install dependencies
        working-directory: ./source
        run: |
          echo "üì¶ Installing dependencies..."
          pnpm install --frozen-lockfile
          echo "‚úÖ Dependencies installed"

      - name: Build shared packages
        working-directory: ./source
        run: |
          echo "üî® Building shared packages..."
          pnpm --filter @dculus/types build
          pnpm --filter @dculus/utils build
          pnpm --filter @dculus/ui build
          echo "‚úÖ Shared packages built"

      - name: Build admin-app with environment-specific variables
        working-directory: ./source
        env:
          VITE_GRAPHQL_URL: https://${{ needs.terraform-cloudflare-service-domain.outputs.service_domain }}/graphql
          VITE_API_URL: https://${{ needs.terraform-cloudflare-service-domain.outputs.service_domain }}
          VITE_CDN_ENDPOINT: ${{ needs.terraform-infrastructure-deploy.outputs.public_cdn_url }}
        run: |
          echo "üî® Building admin-app for environment: ${{ needs.determine-environment.outputs.environment }}"
          echo "Backend URL: $VITE_API_URL"
          echo "GraphQL URL: $VITE_GRAPHQL_URL"
          echo "CDN Endpoint: $VITE_CDN_ENDPOINT"

          pnpm --filter admin-app build

          echo "‚úÖ admin-app build completed"
          ls -la apps/admin-app/dist/

      - name: Install wrangler
        run: npm install -g wrangler

      - name: Deploy to Cloudflare Pages
        working-directory: ./source
        env:
          CLOUDFLARE_API_TOKEN: ${{ secrets.CLOUDFLARE_API_TOKEN }}
          CLOUDFLARE_ACCOUNT_ID: ${{ secrets.CLOUDFLARE_ACCOUNT_ID }}
          RELEASE_TAG: ${{ needs.determine-environment.outputs.release_tag }}
          RELEASE_COMMIT: ${{ needs.determine-environment.outputs.release_commit }}
        run: |
          echo "üöÄ Deploying to Cloudflare Pages..."
          echo "Project: form-admin-app-${{ needs.determine-environment.outputs.environment }}"

          wrangler pages deploy apps/admin-app/dist \
            --project-name=form-admin-app-${{ needs.determine-environment.outputs.environment }} \
            --branch=main \
            --commit-hash=${RELEASE_COMMIT} \
            --commit-message="Deploy release ${RELEASE_TAG} to ${{ needs.determine-environment.outputs.environment }}"

          echo "‚úÖ Deployment completed"

      - name: Purge Cloudflare cache
        env:
          CLOUDFLARE_API_TOKEN: ${{ secrets.CLOUDFLARE_API_TOKEN }}
          CLOUDFLARE_ZONE_ID: ${{ secrets.CLOUDFLARE_ZONE_ID }}
        run: |
          echo "üîÑ Purging Cloudflare cache for immediate visibility..."
          
          PURGE_RESPONSE=$(curl -X POST "https://api.cloudflare.com/client/v4/zones/${CLOUDFLARE_ZONE_ID}/purge_cache" \
            -H "Authorization: Bearer ${CLOUDFLARE_API_TOKEN}" \
            -H "Content-Type: application/json" \
            --data '{"purge_everything":true}' \
            --silent \
            --show-error)
          
          if echo "$PURGE_RESPONSE" | grep -q '"success":true'; then
            echo "‚úÖ Cache purged successfully"
            echo "üí° Changes should be visible immediately without CDN cache delays"
          else
            echo "‚ö†Ô∏è Cache purge may have failed, but deployment was successful"
            echo "Response: $PURGE_RESPONSE"
          fi

      - name: Health check deployment
        run: |
          CUSTOM_DOMAIN="${{ needs.terraform-cloudflare-pages-admin.outputs.custom_domain }}"
          echo "üîç Checking deployment at: $CUSTOM_DOMAIN"

          # Wait for DNS propagation and deployment
          echo "‚è≥ Waiting 60 seconds for DNS propagation..."
          sleep 60

          # Retry health check up to 5 times
          MAX_RETRIES=5
          RETRY_COUNT=0

          while [ $RETRY_COUNT -lt $MAX_RETRIES ]; do
            HTTP_CODE=$(curl -s -o /dev/null -w "%{http_code}" -L "$CUSTOM_DOMAIN" || echo "000")

            if [ "$HTTP_CODE" = "200" ]; then
              echo "‚úÖ Health check passed! (HTTP $HTTP_CODE)"
              echo "üåê admin-app is live at: $CUSTOM_DOMAIN"
              exit 0
            else
              RETRY_COUNT=$((RETRY_COUNT + 1))
              echo "‚ö†Ô∏è Health check attempt $RETRY_COUNT/$MAX_RETRIES failed (HTTP $HTTP_CODE)"

              if [ $RETRY_COUNT -lt $MAX_RETRIES ]; then
                echo "‚è≥ Waiting 30 seconds before retry..."
                sleep 30
              fi
            fi
          done

          echo "‚ùå Health check failed after $MAX_RETRIES attempts"
          echo "üí° Check Cloudflare Pages dashboard: https://dash.cloudflare.com/${{ secrets.CLOUDFLARE_ACCOUNT_ID }}/pages/view/form-admin-app-${{ needs.determine-environment.outputs.environment }}"
          exit 1

      - name: Deployment summary
        if: success()
        run: |
          echo "‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ"
          echo "‚úÖ admin-app Deployment Successful"
          echo "‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ"
          echo ""
          echo "üì¶ Release: ${{ env.RELEASE_TAG }}"
          echo "üåç Environment: ${{ needs.determine-environment.outputs.environment }}"
          echo "üåê URL: ${{ needs.terraform-cloudflare-pages-admin.outputs.custom_domain }}"
          echo "üìä Backend: https://${{ needs.terraform-cloudflare-service-domain.outputs.service_domain }}"
          echo ""
          echo "‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ"

  terraform-cloudflare-pages-viewer:
    name: 5.4. Setup Pages Infrastructure & Domain (form-viewer)
    runs-on: ubuntu-latest
    needs: [determine-environment, setup-azure-backend, terraform-infrastructure-deploy]
    if: |
      always() && !cancelled() && !failure() &&
      needs.determine-environment.outputs.should_deploy == 'true' &&
      needs.determine-environment.outputs.deploy_cloudflare == 'true' &&
      needs.terraform-infrastructure-deploy.result == 'success'
    environment: ${{ needs.determine-environment.outputs.environment }}
    outputs:
      pages_project_name: ${{ steps.apply.outputs.pages_project_name }}
      pages_url: ${{ steps.apply.outputs.pages_url }}
      custom_domain: ${{ steps.apply.outputs.custom_domain }}
    defaults:
      run:
        working-directory: ${{ env.CLOUDFLARE_PAGES_VIEWER_TERRAFORM_DIR }}/environments/${{ needs.determine-environment.outputs.environment }}
    env:
      CLOUDFLARE_API_TOKEN: ${{ secrets.CLOUDFLARE_API_TOKEN }}
      TF_VAR_cloudflare_account_id: ${{ secrets.CLOUDFLARE_ACCOUNT_ID }}
      TF_VAR_cloudflare_api_token: ${{ secrets.CLOUDFLARE_API_TOKEN }}
      TF_VAR_cloudflare_zone_id: ${{ secrets.CLOUDFLARE_ZONE_ID }}
      TF_VAR_environment: ${{ needs.determine-environment.outputs.environment }}
    steps:
      - name: Checkout code
        uses: actions/checkout@v4
        with:
          path: dculus-forms

      - name: Azure Login (OIDC)
        uses: azure/login@v2
        with:
          client-id: ${{ secrets.AZURE_CLIENT_ID }}
          tenant-id: ${{ secrets.AZURE_TENANT_ID }}
          subscription-id: ${{ secrets.AZURE_SUBSCRIPTION_ID }}

      - name: Get Azure Storage Account Key
        id: get-storage-key
        run: |
          ACCOUNT_KEY=$(az storage account keys list \
            --resource-group dculus-global-terraform-assets-resource-grp \
            --account-name dculusterraformstates \
            --query '[0].value' -o tsv)
          echo "::add-mask::$ACCOUNT_KEY"
          echo "ARM_ACCESS_KEY=$ACCOUNT_KEY" >> $GITHUB_ENV

      - name: Setup Terraform
        uses: hashicorp/setup-terraform@v3
        with:
          terraform_version: ${{ env.TERRAFORM_VERSION }}
          terraform_wrapper: false

      - name: Copy shared Terraform files
        run: |
          cp ../../main.tf .
          cp ../../variables.tf .
          cp ../../outputs.tf .
          cp ../../cloudflare-pages-domain.tf .
          echo "‚úÖ Copied shared Terraform files"

      - name: Terraform Init
        run: |
          terraform init \
            -backend-config="resource_group_name=dculus-global-terraform-assets-resource-grp" \
            -backend-config="storage_account_name=dculusterraformstates" \
            -backend-config="container_name=dculus-forms-cloudflare-pages-viewer-${{ needs.determine-environment.outputs.environment }}-state" \
            -backend-config="key=terraform.tfstate"

      - name: Terraform Validate
        run: terraform validate

      - name: Terraform Plan
        run: terraform plan -out=tfplan

      - name: Terraform Apply
        id: apply
        run: |
          terraform apply -auto-approve tfplan

          echo "pages_project_name=$(terraform output -raw pages_project_name)" >> $GITHUB_OUTPUT
          echo "pages_url=$(terraform output -raw pages_url)" >> $GITHUB_OUTPUT
          echo "custom_domain=$(terraform output -raw custom_domain)" >> $GITHUB_OUTPUT

          echo "‚úÖ Cloudflare Pages project created: $(terraform output -raw pages_project_name)"
          echo "üìç Custom domain: $(terraform output -raw custom_domain)"

  deploy-cloudflare-pages-viewer-app:
    name: 6.3. Build & Deploy Frontend (form-viewer)
    runs-on: ubuntu-latest
    needs:
      - determine-environment
      - terraform-infrastructure-deploy
      - terraform-cloudflare-service-domain
      - terraform-cloudflare-pages-viewer
    if: |
      always() && !cancelled() && !failure() &&
      needs.determine-environment.outputs.should_deploy == 'true' &&
      needs.determine-environment.outputs.deploy_cloudflare == 'true' &&
      needs.terraform-cloudflare-service-domain.result == 'success' &&
      needs.terraform-cloudflare-pages-viewer.result == 'success'
    environment: ${{ needs.determine-environment.outputs.environment }}
    steps:
      - name: Prepare release metadata
        run: |
          echo "RELEASE_TAG=${{ needs.determine-environment.outputs.release_tag }}" >> $GITHUB_ENV
          echo "RELEASE_COMMIT=${{ needs.determine-environment.outputs.release_commit }}" >> $GITHUB_ENV
          echo "üì¶ Deploying tag: ${{ needs.determine-environment.outputs.release_tag }}"

      - name: Checkout source code
        uses: actions/checkout@v4
        with:
          ref: ${{ needs.determine-environment.outputs.release_commit }}
          path: source

      - name: Setup Node.js
        uses: actions/setup-node@v4
        with:
          node-version: '20'

      - name: Setup pnpm
        uses: pnpm/action-setup@v2
        with:
          version: 8

      - name: Install dependencies
        working-directory: ./source
        run: |
          echo "üì¶ Installing dependencies..."
          pnpm install --frozen-lockfile
          echo "‚úÖ Dependencies installed"

      - name: Build shared packages
        working-directory: ./source
        run: |
          echo "üî® Building shared packages..."
          pnpm --filter @dculus/types build
          pnpm --filter @dculus/utils build
          pnpm --filter @dculus/ui build
          echo "‚úÖ Shared packages built"

      - name: Build form-viewer with environment-specific variables
        working-directory: ./source
        env:
          VITE_GRAPHQL_URL: https://${{ needs.terraform-cloudflare-service-domain.outputs.service_domain }}/graphql
          VITE_API_URL: https://${{ needs.terraform-cloudflare-service-domain.outputs.service_domain }}
          VITE_CDN_ENDPOINT: ${{ needs.terraform-infrastructure-deploy.outputs.public_cdn_url }}
        run: |
          echo "üî® Building form-viewer for environment: ${{ needs.determine-environment.outputs.environment }}"
          echo "Backend URL: $VITE_API_URL"
          echo "GraphQL URL: $VITE_GRAPHQL_URL"
          echo "CDN Endpoint: $VITE_CDN_ENDPOINT"

          pnpm --filter form-viewer build

          echo "‚úÖ form-viewer build completed"
          ls -la apps/form-viewer/dist/

      - name: Install wrangler
        run: npm install -g wrangler

      - name: Deploy to Cloudflare Pages
        working-directory: ./source
        env:
          CLOUDFLARE_API_TOKEN: ${{ secrets.CLOUDFLARE_API_TOKEN }}
          CLOUDFLARE_ACCOUNT_ID: ${{ secrets.CLOUDFLARE_ACCOUNT_ID }}
          RELEASE_TAG: ${{ needs.determine-environment.outputs.release_tag }}
          RELEASE_COMMIT: ${{ needs.determine-environment.outputs.release_commit }}
        run: |
          echo "üöÄ Deploying to Cloudflare Pages..."
          echo "Project: viewer-app-${{ needs.determine-environment.outputs.environment }}"

          wrangler pages deploy apps/form-viewer/dist \
            --project-name=viewer-app-${{ needs.determine-environment.outputs.environment }} \
            --branch=main \
            --commit-hash=${RELEASE_COMMIT} \
            --commit-message="Deploy release ${RELEASE_TAG} to ${{ needs.determine-environment.outputs.environment }}"

          echo "‚úÖ Deployment completed"

      - name: Purge Cloudflare cache
        env:
          CLOUDFLARE_API_TOKEN: ${{ secrets.CLOUDFLARE_API_TOKEN }}
          CLOUDFLARE_ZONE_ID: ${{ secrets.CLOUDFLARE_ZONE_ID }}
        run: |
          echo "üîÑ Purging Cloudflare cache for immediate visibility..."
          
          PURGE_RESPONSE=$(curl -X POST "https://api.cloudflare.com/client/v4/zones/${CLOUDFLARE_ZONE_ID}/purge_cache" \
            -H "Authorization: Bearer ${CLOUDFLARE_API_TOKEN}" \
            -H "Content-Type: application/json" \
            --data '{"purge_everything":true}' \
            --silent \
            --show-error)
          
          if echo "$PURGE_RESPONSE" | grep -q '"success":true'; then
            echo "‚úÖ Cache purged successfully"
            echo "üí° Changes should be visible immediately without CDN cache delays"
          else
            echo "‚ö†Ô∏è Cache purge may have failed, but deployment was successful"
            echo "Response: $PURGE_RESPONSE"
          fi

      - name: Health check deployment
        run: |
          CUSTOM_DOMAIN="${{ needs.terraform-cloudflare-pages-viewer.outputs.custom_domain }}"
          echo "üîç Checking deployment at: $CUSTOM_DOMAIN"

          # Wait for DNS propagation and deployment
          echo "‚è≥ Waiting 60 seconds for DNS propagation..."
          sleep 60

          # Retry health check up to 5 times
          MAX_RETRIES=5
          RETRY_COUNT=0

          while [ $RETRY_COUNT -lt $MAX_RETRIES ]; do
            HTTP_CODE=$(curl -s -o /dev/null -w "%{http_code}" -L "$CUSTOM_DOMAIN" || echo "000")

            if [ "$HTTP_CODE" = "200" ]; then
              echo "‚úÖ Health check passed! (HTTP $HTTP_CODE)"
              echo "üåê form-viewer is live at: $CUSTOM_DOMAIN"
              exit 0
            else
              RETRY_COUNT=$((RETRY_COUNT + 1))
              echo "‚ö†Ô∏è Health check attempt $RETRY_COUNT/$MAX_RETRIES failed (HTTP $HTTP_CODE)"

              if [ $RETRY_COUNT -lt $MAX_RETRIES ]; then
                echo "‚è≥ Waiting 30 seconds before retry..."
                sleep 30
              fi
            fi
          done

          echo "‚ùå Health check failed after $MAX_RETRIES attempts"
          echo "üí° Check Cloudflare Pages dashboard: https://dash.cloudflare.com/${{ secrets.CLOUDFLARE_ACCOUNT_ID }}/pages/view/viewer-app-${{ needs.determine-environment.outputs.environment }}"
          exit 1

      - name: Deployment summary
        if: success()
        run: |
          echo "‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ"
          echo "‚úÖ form-viewer Deployment Successful"
          echo "‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ"
          echo ""
          echo "üì¶ Release: ${{ env.RELEASE_TAG }}"
          echo "üåç Environment: ${{ needs.determine-environment.outputs.environment }}"
          echo "üåê URL: ${{ needs.terraform-cloudflare-pages-viewer.outputs.custom_domain }}"
          echo "üìä Backend: https://${{ needs.terraform-cloudflare-service-domain.outputs.service_domain }}"
          echo ""
          echo "‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ"

  run-form-app-e2e:
    name: 7.2. Run form-app E2E (Cloudflare Pages)
    runs-on: ubuntu-latest
    needs:
      - determine-environment
      - deploy-cloudflare-pages-form-app
      - health-checks
    if: |
      always() && !cancelled() && !failure() &&
      needs.determine-environment.outputs.should_deploy == 'true' &&
      needs.determine-environment.outputs.deploy_cloudflare == 'true' &&
      needs.deploy-cloudflare-pages-form-app.result == 'success' &&
      needs.health-checks.result == 'success'
    env:
      E2E_EMAIL: ${{ secrets.E2E_INTEGRATION_TEST_EMAIL_ID }}
      E2E_PASSWORD: ${{ secrets.E2E_INTEGRATION_TEST_PASSWORD }}
      E2E_FORM_APP_URL: ${{ secrets.E2E_INTEGRATION_TEST_FORM_APP_URL }}
      E2E_BACKEND_URL: ${{ secrets.E2E_INTEGRATION_TEST_BACKEND_URL }}
      E2E_FORM_VIEWER_URL: ${{ secrets.E2E_INTEGRATION_TEST_FORM_VIEWER_URL }}
      E2E_HEADLESS: 'true'
      CI: 'true'
    steps:
      - name: Checkout source code
        uses: actions/checkout@v4
        with:
          ref: ${{ needs.determine-environment.outputs.release_commit }}
          path: source

      - name: Validate e2e secrets
        run: |
          if [ -z "$E2E_EMAIL" ] || [ -z "$E2E_PASSWORD" ] || [ -z "$E2E_FORM_APP_URL" ] || [ -z "$E2E_FORM_VIEWER_URL" ]; then
            echo "‚ùå E2E secrets are not configured (E2E_EMAIL/E2E_PASSWORD/E2E_FORM_APP_URL/E2E_FORM_VIEWER_URL)."
            exit 1
          fi

      - name: Setup Node.js
        uses: actions/setup-node@v4
        with:
          node-version: '20'

      - name: Setup pnpm
        uses: pnpm/action-setup@v2
        with:
          version: 8

      - name: Install dependencies
        working-directory: ./source
        run: pnpm install --frozen-lockfile

      - name: Install Playwright browsers
        working-directory: ./source
        run: pnpm exec playwright install --with-deps

      - name: Run e2e tests against Cloudflare Pages
        working-directory: ./source
        run: pnpm test:e2e

      - name: Upload e2e artifacts on failure
        if: failure()
        uses: actions/upload-artifact@v4
        with:
          name: form-app-e2e-artifacts
          path: |
            source/test-results/e2e/**
          if-no-files-found: ignore

  # ============================================================
  # PHASE 7: SSL CERTIFICATE & CUSTOM DOMAIN (Backend)
  # ============================================================

  configure-azure-custom-domain:
    name: 7.1. Configure Backend SSL Certificate
    runs-on: ubuntu-latest
    needs: [determine-environment, terraform-infrastructure-deploy, terraform-cloudflare-service-domain]
    if: |
      always() && !cancelled() && !failure() &&
      needs.determine-environment.outputs.should_deploy == 'true' &&
      needs.determine-environment.outputs.deploy_cloudflare == 'true' &&
      needs.determine-environment.outputs.deploy_azure == 'true' &&
      needs.terraform-cloudflare-service-domain.result == 'success'
    environment: ${{ needs.determine-environment.outputs.environment }}
    steps:
      - name: Checkout code
        uses: actions/checkout@v4

      - name: Azure Login (OIDC)
        uses: azure/login@v2
        with:
          client-id: ${{ secrets.AZURE_CLIENT_ID }}
          tenant-id: ${{ secrets.AZURE_TENANT_ID }}
          subscription-id: ${{ secrets.AZURE_SUBSCRIPTION_ID }}

      - name: Set environment variables
        id: set-env
        run: |
          ENV="${{ needs.determine-environment.outputs.environment }}"

          # Set resource names based on environment
          echo "RESOURCE_GROUP=dculus-forms-${ENV}-rg" >> $GITHUB_ENV
          echo "CONTAINER_APP_NAME=dculus-forms-${ENV}-backend" >> $GITHUB_ENV
          echo "CONTAINER_ENV_NAME=dculus-forms-${ENV}-env" >> $GITHUB_ENV
          echo "CUSTOM_DOMAIN=${{ needs.terraform-cloudflare-service-domain.outputs.service_domain }}" >> $GITHUB_ENV
          echo "ENVIRONMENT=${ENV}" >> $GITHUB_ENV

          echo "üìã Configuration:"
          echo "  Environment: ${ENV}"
          echo "  Resource Group: dculus-forms-${ENV}-rg"
          echo "  Container App: dculus-forms-${ENV}-backend"
          echo "  Custom Domain: ${{ needs.terraform-cloudflare-service-domain.outputs.service_domain }}"

      - name: Run custom domain configuration script
        env:
          CLOUDFLARE_ZONE_ID: ${{ secrets.CLOUDFLARE_ZONE_ID }}
          CLOUDFLARE_API_TOKEN: ${{ secrets.CLOUDFLARE_API_TOKEN }}
        run: |
          chmod +x .github/scripts/configure-azure-custom-domain.sh
          ./.github/scripts/configure-azure-custom-domain.sh

      - name: Display configuration summary
        if: always()
        run: |
          echo "==================== Configuration Summary ===================="
          echo "Custom Domain: ${CUSTOM_DOMAIN}"

          # Get final binding status
          BINDING_STATUS=$(az containerapp hostname list \
            --name "${CONTAINER_APP_NAME}" \
            --resource-group "${RESOURCE_GROUP}" \
            --output json | jq -r --arg domain "${CUSTOM_DOMAIN}" '.[] | select(.name == $domain) | .bindingType // "Not configured"')

          echo "Binding Status: ${BINDING_STATUS}"

          # Get certificate info
          CERT_INFO=$(az containerapp env certificate list \
            --name "${CONTAINER_ENV_NAME}" \
            --resource-group "${RESOURCE_GROUP}" \
            --managed-certificates-only \
            --output json 2>/dev/null | jq -r --arg domain "${CUSTOM_DOMAIN}" '.[] | select(.properties.subjectName == $domain) | "Certificate: \(.name) | Status: \(.properties.provisioningState)"' || echo "Certificate: Not found")

          echo "${CERT_INFO}"
          echo "================================================================"

  # ============================================================
  # PHASE 8: POST-DEPLOYMENT VALIDATION
  # ============================================================

  health-checks:
    name: 8.1. Run Health Checks
    runs-on: ubuntu-latest
    needs: [determine-environment, terraform-infrastructure-deploy]
    if: |
      always() && !cancelled() &&
      needs.terraform-infrastructure-deploy.result == 'success'
    steps:
      - name: Wait for backend to be ready
        run: |
          echo "‚è≥ Waiting 30 seconds for backend to stabilize..."
          sleep 30

      - name: Check backend health endpoint
        run: |
          HEALTH_URL="${{ needs.terraform-infrastructure-deploy.outputs.health_endpoint }}"
          echo "üè• Checking health endpoint: $HEALTH_URL"

          MAX_RETRIES=5
          RETRY_COUNT=0

          while [ $RETRY_COUNT -lt $MAX_RETRIES ]; do
            if curl -sf "$HEALTH_URL" -o /dev/null; then
              echo "‚úÖ Health check passed!"
              exit 0
            else
              RETRY_COUNT=$((RETRY_COUNT + 1))
              echo "‚ö†Ô∏è Health check failed (attempt $RETRY_COUNT/$MAX_RETRIES)"
              if [ $RETRY_COUNT -lt $MAX_RETRIES ]; then
                echo "‚è≥ Waiting 15 seconds before retry..."
                sleep 15
              fi
            fi
          done

          echo "‚ùå Health check failed after $MAX_RETRIES attempts"
          exit 1

      - name: Check GraphQL endpoint
        run: |
          GRAPHQL_URL="${{ needs.terraform-infrastructure-deploy.outputs.graphql_endpoint }}"
          echo "üîç Checking GraphQL endpoint: $GRAPHQL_URL"

          RESPONSE=$(curl -sf -X POST "$GRAPHQL_URL" \
            -H "Content-Type: application/json" \
            -d '{"query":"{ __typename }"}')

          if echo "$RESPONSE" | grep -q "__typename"; then
            echo "‚úÖ GraphQL endpoint is responding correctly!"
          else
            echo "‚ö†Ô∏è GraphQL endpoint returned unexpected response"
            echo "$RESPONSE"
          fi

  # ============================================================
  # PHASE 9: DEPLOYMENT SUMMARY
  # ============================================================

  deployment-summary:
    name: 9.1. Generate Deployment Summary
    runs-on: ubuntu-latest
    needs: [
      determine-environment,
      terraform-infrastructure-deploy,
      terraform-cloudflare-service-domain,
      terraform-cloudflare-pages,
      terraform-cloudflare-pages-admin,
      terraform-cloudflare-pages-viewer,
      deploy-cloudflare-pages-form-app,
      deploy-cloudflare-pages-admin-app,
      deploy-cloudflare-pages-viewer-app,
      run-form-app-e2e,
      configure-azure-custom-domain,
      health-checks
    ]
    if: always()
    steps:
      - name: Generate Summary
        run: |
          echo "# üöÄ Multi-Cloud Deployment Summary" >> $GITHUB_STEP_SUMMARY
          echo "" >> $GITHUB_STEP_SUMMARY
          echo "**Environment**: \`${{ needs.determine-environment.outputs.environment }}\`" >> $GITHUB_STEP_SUMMARY
          echo "**Branch/Ref**: \`${{ github.ref }}\`" >> $GITHUB_STEP_SUMMARY
          echo "**Triggered by**: @${{ github.actor }}" >> $GITHUB_STEP_SUMMARY
          echo "**Event**: \`${{ github.event_name }}\`" >> $GITHUB_STEP_SUMMARY
          echo "" >> $GITHUB_STEP_SUMMARY

          echo "## üìä Job Status" >> $GITHUB_STEP_SUMMARY
          echo "" >> $GITHUB_STEP_SUMMARY
          echo "| Component | Status |" >> $GITHUB_STEP_SUMMARY
          echo "|-----------|--------|" >> $GITHUB_STEP_SUMMARY
          echo "| Infrastructure (R2 + Container Apps) | ${{ needs.terraform-infrastructure-deploy.result == 'success' && '‚úÖ' || needs.terraform-infrastructure-deploy.result == 'skipped' && '‚è≠Ô∏è' || '‚ùå' }} |" >> $GITHUB_STEP_SUMMARY
          echo "| Cloudflare Service Domain | ${{ needs.terraform-cloudflare-service-domain.result == 'success' && '‚úÖ' || needs.terraform-cloudflare-service-domain.result == 'skipped' && '‚è≠Ô∏è' || '‚ùå' }} |" >> $GITHUB_STEP_SUMMARY

          # Infrastructure Deployment Summary (Cloudflare R2 + Azure Container Apps)
          if [ "${{ needs.terraform-infrastructure-deploy.result }}" = "success" ]; then
            echo "## ‚òÅÔ∏è Cloudflare R2 Deployment" >> $GITHUB_STEP_SUMMARY
            echo "" >> $GITHUB_STEP_SUMMARY
            echo "- **Private Bucket**: \`${{ needs.terraform-infrastructure-deploy.outputs.private_bucket }}\`" >> $GITHUB_STEP_SUMMARY
            echo "- **Public Bucket**: \`${{ needs.terraform-infrastructure-deploy.outputs.public_bucket }}\`" >> $GITHUB_STEP_SUMMARY
            echo "- **R2 Endpoint**: \`https://${{ secrets.CLOUDFLARE_ACCOUNT_ID }}.r2.cloudflarestorage.com\`" >> $GITHUB_STEP_SUMMARY
            echo "" >> $GITHUB_STEP_SUMMARY

            echo "## üî∑ Azure Container Apps Deployment" >> $GITHUB_STEP_SUMMARY
            echo "" >> $GITHUB_STEP_SUMMARY
            echo "- **Backend URL**: [${{ needs.terraform-infrastructure-deploy.outputs.backend_url }}](${{ needs.terraform-infrastructure-deploy.outputs.backend_url }})" >> $GITHUB_STEP_SUMMARY
            echo "- **GraphQL Endpoint**: [${{ needs.terraform-infrastructure-deploy.outputs.graphql_endpoint }}](${{ needs.terraform-infrastructure-deploy.outputs.graphql_endpoint }})" >> $GITHUB_STEP_SUMMARY
            echo "- **Health Check**: [${{ needs.terraform-infrastructure-deploy.outputs.health_endpoint }}](${{ needs.terraform-infrastructure-deploy.outputs.health_endpoint }})" >> $GITHUB_STEP_SUMMARY
            echo "- **Container App**: \`${{ needs.terraform-infrastructure-deploy.outputs.container_app_name }}\`" >> $GITHUB_STEP_SUMMARY
            echo "" >> $GITHUB_STEP_SUMMARY
          fi

          # Cloudflare Service Domain Summary
          if [ "${{ needs.terraform-cloudflare-service-domain.result }}" = "success" ]; then
            echo "## üåê Form Services Domain" >> $GITHUB_STEP_SUMMARY
            echo "" >> $GITHUB_STEP_SUMMARY
            echo "- **Hostname**: \`${{ needs.terraform-cloudflare-service-domain.outputs.service_domain }}\`" >> $GITHUB_STEP_SUMMARY
            echo "- **Target FQDN**: \`${{ needs.terraform-cloudflare-service-domain.outputs.target_backend_fqdn }}\`" >> $GITHUB_STEP_SUMMARY
            echo "" >> $GITHUB_STEP_SUMMARY
          fi

          # Cloudflare Pages Deployment Summary
          if [ "${{ needs.deploy-cloudflare-pages-form-app.result }}" = "success" ]; then
            echo "## üì± form-app Deployment (Cloudflare Pages)" >> $GITHUB_STEP_SUMMARY
            echo "" >> $GITHUB_STEP_SUMMARY
            echo "- **Project**: \`${{ needs.terraform-cloudflare-pages.outputs.pages_project_name }}\`" >> $GITHUB_STEP_SUMMARY
            echo "- **Custom Domain**: [${{ needs.terraform-cloudflare-pages.outputs.custom_domain }}](${{ needs.terraform-cloudflare-pages.outputs.custom_domain }})" >> $GITHUB_STEP_SUMMARY
            echo "- **Pages URL**: [${{ needs.terraform-cloudflare-pages.outputs.pages_url }}](${{ needs.terraform-cloudflare-pages.outputs.pages_url }})" >> $GITHUB_STEP_SUMMARY
            echo "- **Backend**: \`https://${{ needs.terraform-cloudflare-service-domain.outputs.service_domain }}\`" >> $GITHUB_STEP_SUMMARY
            echo "- **Status**: ‚úÖ Deployed and health check passed" >> $GITHUB_STEP_SUMMARY
            echo "" >> $GITHUB_STEP_SUMMARY
          fi

          # Admin App Deployment Summary
          if [ "${{ needs.deploy-cloudflare-pages-admin-app.result }}" = "success" ]; then
            echo "## üîß admin-app Deployment (Cloudflare Pages)" >> $GITHUB_STEP_SUMMARY
            echo "" >> $GITHUB_STEP_SUMMARY
            echo "- **Project**: \`${{ needs.terraform-cloudflare-pages-admin.outputs.pages_project_name }}\`" >> $GITHUB_STEP_SUMMARY
            echo "- **Custom Domain**: [${{ needs.terraform-cloudflare-pages-admin.outputs.custom_domain }}](${{ needs.terraform-cloudflare-pages-admin.outputs.custom_domain }})" >> $GITHUB_STEP_SUMMARY
            echo "- **Pages URL**: [${{ needs.terraform-cloudflare-pages-admin.outputs.pages_url }}](${{ needs.terraform-cloudflare-pages-admin.outputs.pages_url }})" >> $GITHUB_STEP_SUMMARY
            echo "- **Backend**: \`https://${{ needs.terraform-cloudflare-service-domain.outputs.service_domain }}\`" >> $GITHUB_STEP_SUMMARY
            echo "- **Status**: ‚úÖ Deployed and health check passed" >> $GITHUB_STEP_SUMMARY
            echo "" >> $GITHUB_STEP_SUMMARY
          fi

          # Viewer App Deployment Summary
          if [ "${{ needs.deploy-cloudflare-pages-viewer-app.result }}" = "success" ]; then
            echo "## üëÅÔ∏è form-viewer Deployment (Cloudflare Pages)" >> $GITHUB_STEP_SUMMARY
            echo "" >> $GITHUB_STEP_SUMMARY
            echo "- **Project**: \`${{ needs.terraform-cloudflare-pages-viewer.outputs.pages_project_name }}\`" >> $GITHUB_STEP_SUMMARY
            echo "- **Custom Domain**: [${{ needs.terraform-cloudflare-pages-viewer.outputs.custom_domain }}](${{ needs.terraform-cloudflare-pages-viewer.outputs.custom_domain }})" >> $GITHUB_STEP_SUMMARY
            echo "- **Pages URL**: [${{ needs.terraform-cloudflare-pages-viewer.outputs.pages_url }}](${{ needs.terraform-cloudflare-pages-viewer.outputs.pages_url }})" >> $GITHUB_STEP_SUMMARY
            echo "- **Backend**: \`https://${{ needs.terraform-cloudflare-service-domain.outputs.service_domain }}\`" >> $GITHUB_STEP_SUMMARY
            echo "- **Status**: ‚úÖ Deployed and health check passed" >> $GITHUB_STEP_SUMMARY
            echo "" >> $GITHUB_STEP_SUMMARY
          fi

          # Overall Status
          if [ "${{ needs.terraform-infrastructure-deploy.result }}" = "success" ]; then
            echo "## ‚úÖ Deployment Successful!" >> $GITHUB_STEP_SUMMARY
            echo "" >> $GITHUB_STEP_SUMMARY
            echo "All infrastructure has been deployed successfully to the **${{ needs.determine-environment.outputs.environment }}** environment." >> $GITHUB_STEP_SUMMARY
          elif [ "${{ needs.terraform-infrastructure-deploy.result }}" = "skipped" ]; then
            echo "## ‚ÑπÔ∏è Deployment Skipped" >> $GITHUB_STEP_SUMMARY
            echo "" >> $GITHUB_STEP_SUMMARY
            echo "This was a plan-only run (likely from a pull request). No infrastructure changes were applied." >> $GITHUB_STEP_SUMMARY
          else
            echo "## ‚ùå Deployment Issues Detected" >> $GITHUB_STEP_SUMMARY
            echo "" >> $GITHUB_STEP_SUMMARY
            echo "Some deployment jobs encountered errors. Please check the job logs above for details." >> $GITHUB_STEP_SUMMARY
          fi

          echo "" >> $GITHUB_STEP_SUMMARY
          echo "---" >> $GITHUB_STEP_SUMMARY
          echo "" >> $GITHUB_STEP_SUMMARY
          echo "üìñ **Documentation**: [Multi-Cloud Terraform README](https://github.com/${{ github.repository }}/tree/main/infrastructure/multi-cloud/terraform)" >> $GITHUB_STEP_SUMMARY
